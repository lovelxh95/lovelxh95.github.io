<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Morris</title>
  <link rel="stylesheet" href="/css/style.css">
  
  <link rel="alternate" href="/atom.xml" title="Morris" type="application/atom+xml">
  
  <style>
    :root {
      --container-width: 1580px;
    }
  </style>
<meta name="generator" content="Hexo 7.3.0"></head>
<body class="header-fixed">
  <header class="header">
  <div class="header-inner">
    <div class="header-logo">
      <a href="/" style="color: #fff; text-decoration: none; display: flex; align-items: center;">
        
          <svg height="32" aria-hidden="true" viewBox="0 0 16 16" version="1.1" width="32" data-view-component="true" style="fill: white; margin-right: 8px;">
              <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
          </svg>
        
        <span>GitHub</span>
      </a>
    </div>
    <div class="header-nav">
       <!-- Global Nav if needed -->
    </div>
  </div>
</header>

  
  <div class="container">
    <aside class="sidebar">
  <div class="profile-info">
    <img src="/images/img.jpg" alt="Avatar" class="avatar-img">
    <div class="profile-name">lovelxh95</div>
    <div class="profile-bio">分享生活和技术</div>
    
    <ul class="profile-details">
      
      <li>
        <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-location">
            <path fill-rule="evenodd" d="M11.536 3.464a5 5 0 00-7.072 0 5 5 0 000 7.072L8 14.07l3.536-3.534a5 5 0 000-7.072zM8 2a6 6 0 100 12 6 6 0 000-12z"></path><path fill-rule="evenodd" d="M8 9a2 2 0 100-4 2 2 0 000 4z"></path>
        </svg>
        Guangzhou, China
      </li>
      
      
      <li>
        <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-mail">
            <path fill-rule="evenodd" d="M1.75 2A1.75 1.75 0 000 3.75v.736a.75.75 0 000 .027v7.737C0 13.216.784 14 1.75 14h12.5A1.75 1.75 0 0016 12.25v-8.5A1.75 1.75 0 0014.25 2H1.75zM14.5 4.07v-.32a.25.25 0 00-.25-.25H1.75a.25.25 0 00-.25.25v.32L8 7.88l6.5-3.81zm-13 1.07v7.11c0 .138.112.25.25.25h12.5a.25.25 0 00.25-.25V5.14L8 8.75l-6.5-3.61z"></path>
        </svg>
        <a href="mailto:blog@codewith.top">blog@codewith.top</a>
      </li>
      
      
      <li>
        <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-mark-github">
            <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
        </svg>
        <a target="_blank" rel="noopener" href="https://github.com/lovelxh95">GitHub</a>
      </li>
      
    </ul>
  </div>
</aside>

    
    <main class="main-content">
      <div class="tab-nav">
  <div class="tab-nav-inner">
    
      <a class="tab-item " href="/">
        
          <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-book"><path fill-rule="evenodd" d="M0 1.75A.75.75 0 01.75 1h4.253c1.227 0 2.317.59 3 1.501A3.744 3.744 0 0111.006 1h4.245a.75.75 0 01.75.75v10.5a.75.75 0 01-.75.75h-4.507a2.25 2.25 0 00-1.591.659l-.622.621a.75.75 0 01-1.06 0l-.622-.621A2.25 2.25 0 005.255 13H.75a.75.75 0 01-.75-.75V1.75zm1.5 0v10.5h3.755c.535 0 1.05.19 1.46.54l.79.79.79-.79a2.25 2.25 0 011.46-.54h3.755V1.75h-3.755a2.25 2.25 0 00-1.748 3.518l-1.353 1.354a.75.75 0 01-1.06 0L3.498 5.268A2.25 2.25 0 001.75 1.75z"></path></svg>
        
        <span>Overview</span>
      </a>
    
      <a class="tab-item " href="/archives">
        
          <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-repo"><path fill-rule="evenodd" d="M2 2.5A2.5 2.5 0 014.5 0h8.75a.75.75 0 01.75.75v12.5a.75.75 0 01-.75.75h-2.5a.75.75 0 110-1.5h1.75v-2h-8a1 1 0 00-.714 1.7.75.75 0 01-1.072 1.05A2.495 2.495 0 012 11.5v-9zm10.5-1V9h-8c-.356 0-.694.074-1 .208V2.5a1 1 0 011-1h8zM5 12.25v3.25a.25.25 0 00.4.2l1.45-1.087a.25.25 0 01.3 0L8.6 15.7a.25.25 0 00.4-.2v-3.25a.25.25 0 00-.25-.25h-3.5a.25.25 0 00-.25.25z"></path></svg>
        
        <span>Repositories</span>
      </a>
    
      <a class="tab-item " href="/categories">
        
           <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-project"><path fill-rule="evenodd" d="M1.75 0A1.75 1.75 0 000 1.75v12.5C0 15.216.784 16 1.75 16h12.5A1.75 1.75 0 0016 14.25V1.75A1.75 1.75 0 0014.25 0H1.75zM1.5 1.75a.25.25 0 01.25-.25h12.5a.25.25 0 01.25.25v12.5a.25.25 0 01-.25.25H1.75a.25.25 0 01-.25-.25V1.75zM11.75 3a.75.75 0 00-.75.75v7.5a.75.75 0 001.5 0v-7.5a.75.75 0 00-.75-.75zm-8.25.75a.75.75 0 011.5 0v5.5a.75.75 0 01-1.5 0v-5.5zM8 3a.75.75 0 00-.75.75v3.5a.75.75 0 001.5 0v-3.5A.75.75 0 008 3z"></path></svg>
        
        <span>Projects</span>
      </a>
    
      <a class="tab-item " href="/tags">
        
        <span>Stars</span>
      </a>
    
      <a class="tab-item " href="/about">
        
        <span>About</span>
      </a>
    
  </div>
</div>

      <div class="post-layout-wrapper">
  <div class="post-content-container">
    <div class="post-header">
      <h1 style="margin: 0; font-size: 20px; font-weight: 600;">Java开发面试（1）</h1>
      <div class="post-meta" style="margin-top: 8px; font-size: 13px; color: #57606a;">
        <span>2026-01-03</span>
        
        
        
      </div>
    </div>
    
    <div class="post-body">
      <div class="post-content">
        <h2 id="请解释-Java-中集合框架的层次结构，并举例说明-ArrayList-和-LinkedList-的区别及其适用场景"><a href="#请解释-Java-中集合框架的层次结构，并举例说明-ArrayList-和-LinkedList-的区别及其适用场景" class="headerlink" title="请解释 Java 中集合框架的层次结构，并举例说明 ArrayList 和 LinkedList 的区别及其适用场景"></a>请解释 Java 中集合框架的层次结构，并举例说明 ArrayList 和 LinkedList 的区别及其适用场景</h2><h3 id="一、-Java-集合框架的层次结构"><a href="#一、-Java-集合框架的层次结构" class="headerlink" title="一、 Java 集合框架的层次结构"></a>一、 Java 集合框架的层次结构</h3><p>Java 集合框架主要由两大根接口组成：<code>Collection</code> 和 <code>Map</code>。</p>
<ol>
<li><strong>Collection 接口</strong>：存储对象的集合。<ul>
<li><strong>List (有序、可重复)</strong>：<ul>
<li>ArrayList：基于动态数组实现。</li>
<li>LinkedList：基于双向链表实现。</li>
<li>Vector：线程安全（古老，不推荐使用）。</li>
</ul>
</li>
<li><strong>Set (无序、唯一)</strong>：<ul>
<li>HashSet：基于 HashMap 实现，速度快。</li>
<li>TreeSet：支持自然排序或定制排序。</li>
<li>LinkedHashSet：维护插入顺序。</li>
</ul>
</li>
<li><strong>Queue (队列)</strong>：<ul>
<li>PriorityQueue：优先级队列。</li>
<li>Deque：双端队列（LinkedList 也实现了该接口）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Map 接口</strong>：存储键值对（Key-Value）。<ul>
<li>HashMap：最常用，高效。</li>
<li>TreeMap：按 Key 排序。</li>
<li>ConcurrentHashMap：线程安全，常用于高并发场景。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="二、-ArrayList-与-LinkedList-的深度对比"><a href="#二、-ArrayList-与-LinkedList-的深度对比" class="headerlink" title="二、 ArrayList 与 LinkedList 的深度对比"></a>二、 ArrayList 与 LinkedList 的深度对比</h3><p>这两者都实现了 List 接口，但在底层数据结构和性能表现上有本质区别：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>特性</td>
<td>ArrayList</td>
<td>LinkedList</td>
</tr>
<tr>
<td><strong>底层结构</strong></td>
<td><strong>动态数组</strong>（连续内存空间）</td>
<td><strong>双向链表</strong>（非连续内存空间）</td>
</tr>
<tr>
<td><strong>随机访问 (get&#x2F;set)</strong></td>
<td><strong>极快 (<br><br>        <code>O(1)O(1)O(1)</code><br>      <br><br>)</strong>：通过下标直接定位。</td>
<td><strong>慢 (<br><br>        <code>O(n)O(n)O(n)</code><br>      <br><br>)</strong>：需要从头或尾遍历。</td>
</tr>
<tr>
<td><strong>插入&#x2F;删除 (add&#x2F;remove)</strong></td>
<td><strong>较慢 (<br><br>        <code>O(n)O(n)O(n)</code><br>      <br><br>)</strong>：涉及数组扩容和元素移动。</td>
<td><strong>快 (<br><br>        <code>O(1)O(1)O(1)</code><br>      <br><br>)</strong>：仅需修改指针（若已定位到位置）。</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>较小：主要浪费在预留的末尾空间。</td>
<td>较大：每个节点都要存储前驱和后继指针。</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>线程不安全</td>
<td>线程不安全</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<h2 id="什么是-Volatile-关键字？它在多线程环境中的作用是什么？与-Synchronized-的区别是什么？"><a href="#什么是-Volatile-关键字？它在多线程环境中的作用是什么？与-Synchronized-的区别是什么？" class="headerlink" title="什么是 Volatile 关键字？它在多线程环境中的作用是什么？与 Synchronized 的区别是什么？"></a>什么是 Volatile 关键字？它在多线程环境中的作用是什么？与 Synchronized 的区别是什么？</h2><h3 id="一、-什么是-Volatile-关键字？"><a href="#一、-什么是-Volatile-关键字？" class="headerlink" title="一、 什么是 Volatile 关键字？"></a>一、 什么是 Volatile 关键字？</h3><p><code>volatile</code> 是 Java 提供的一种<strong>轻量级的同步机制</strong>。它的核心作用是确保变量的修改对所有线程都是可见的，并防止指令重排序。</p>
<p>在 Java 内存模型（JMM）中，每个线程有自己的工作内存（私有缓存），线程操作变量时会先从主内存拷贝一份。如果一个变量没被 <code>volatile</code> 修饰，线程修改完后可能不会立即写回主内存，导致其他线程读到的是旧值。</p>
<hr>
<h3 id="二、-Volatile-在多线程中的两大作用"><a href="#二、-Volatile-在多线程中的两大作用" class="headerlink" title="二、 Volatile 在多线程中的两大作用"></a>二、 Volatile 在多线程中的两大作用</h3><ol>
<li><p><strong>保证内存可见性 (Visibility)</strong>：</p>
<ul>
<li>一旦一个变量被声明为 volatile，任何线程对它的修改都会立即刷新到主内存中；同时，其他线程在读取该变量时，会强制从主内存中读取最新值，而不是从自己的工作内存。</li>
</ul>
</li>
<li><p><strong>禁止指令重排序 (Ordering)</strong>：</p>
<ul>
<li>为了优化性能，编译器和处理器可能会对代码指令进行乱序执行。volatile 通过插入“内存屏障（Memory Barrier）”来防止这种重排序。</li>
<li><strong>典型应用：</strong> 单例模式中的 <strong>DCL（双重检查锁）</strong>。如果不加 volatile，在对象初始化时，由于重排序，另一个线程可能会拿到一个“尚未完全初始化完成”的对象引用。</li>
</ul>
</li>
</ol>
<h3 id="三、-Volatile-与-Synchronized-的区别"><a href="#三、-Volatile-与-Synchronized-的区别" class="headerlink" title="三、 Volatile 与 Synchronized 的区别"></a>三、 Volatile 与 Synchronized 的区别</h3><p>虽然两者都用于并发编程，但它们有本质的不同：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>特性</td>
<td>Volatile</td>
<td>Synchronized</td>
</tr>
<tr>
<td><strong>性质</strong></td>
<td>变量修饰符，轻量级。</td>
<td>关键字，可修饰方法或代码块，重量级。</td>
</tr>
<tr>
<td><strong>原子性</strong></td>
<td><strong>不保证原子性</strong>（如 i++ 操作无法保证正确）。</td>
<td><strong>保证原子性</strong>（同一时间只有一个线程执行）。</td>
</tr>
<tr>
<td><strong>可见性</strong></td>
<td>保证可见性。</td>
<td>保证可见性（解锁前必须刷新回主内存）。</td>
</tr>
<tr>
<td><strong>阻塞</strong></td>
<td><strong>不会</strong>造成线程阻塞，性能高。</td>
<td><strong>会</strong>造成线程阻塞，涉及上下文切换，性能相对较低。</td>
</tr>
<tr>
<td><strong>有序性</strong></td>
<td>保证有序性（禁止重排序）。</td>
<td>保证有序性（通过互斥保证单线程执行）。</td>
</tr>
</tbody></table>
<hr>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>在实际开发中（如我简历中提到的广告引擎维护）：</p>
<ul>
<li><strong>使用 volatile 的场景：</strong> 当你需要一个简单的“状态标记位”（如 isReady, isShutdown），且该变量的操作不依赖当前值（即不需要 i++ 这种操作）时，volatile 是性能最优的选择。</li>
<li><strong>使用 synchronized 的场景：</strong> 当你需要执行复杂的复合操作，或者需要保证操作的“原子性”时（例如在“问卷系统”中扣减优惠券额度、更新计数器），必须使用 synchronized 或 ReentrantLock。</li>
</ul>
<p><strong>总结：</strong> volatile 解决了“看得到”的问题，而 synchronized 解决了“写得准”的问题。在追求高并发性能时，我会优先考虑 volatile 或 Atomic 原子类，只有在必要时才使用较重的锁机制。</p>
<hr>
<h2 id="描述-ReentrantLock-的实现原理，以及它与-Synchronized-的比较（包括公平锁和非公平锁）"><a href="#描述-ReentrantLock-的实现原理，以及它与-Synchronized-的比较（包括公平锁和非公平锁）" class="headerlink" title="描述 ReentrantLock 的实现原理，以及它与 Synchronized 的比较（包括公平锁和非公平锁）"></a>描述 ReentrantLock 的实现原理，以及它与 Synchronized 的比较（包括公平锁和非公平锁）</h2><h3 id="一、-ReentrantLock-的实现原理"><a href="#一、-ReentrantLock-的实现原理" class="headerlink" title="一、 ReentrantLock 的实现原理"></a>一、 ReentrantLock 的实现原理</h3><p>ReentrantLock 的核心是基于 <strong>AQS（AbstractQueuedSynchronizer，抽象队列同步器）</strong> 实现的。</p>
<ol>
<li><p><strong>状态管理（state）</strong>：AQS 内部维护一个 volatile 修饰的 state 变量。</p>
<ul>
<li>当 state &#x3D; 0 时，表示锁未被占用。</li>
<li>线程尝试通过 <strong>CAS（Compare-And-Swap）</strong> 操作将 state 从 0 修改为 1 来获取锁。</li>
</ul>
</li>
<li><p><strong>重入性实现</strong>：</p>
<ul>
<li>如果获取锁的线程是“当前占有锁的线程”，则 state 加 1，这就是“可重入”的体现。</li>
<li>释放锁时，state 减 1，直到 state &#x3D; 0 时锁才完全释放。</li>
</ul>
</li>
<li><p><strong>等待队列（CLH 变体）</strong>：</p>
<ul>
<li>如果 CAS 失败（锁已被占用），线程会被封装成一个 Node 节点，进入一个双向同步队列中挂起（LockSupport.park）。</li>
<li>当持有锁的线程释放锁后，会唤醒队列中头节点的下一个节点尝试获取锁。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="二、-ReentrantLock-vs-Synchronized"><a href="#二、-ReentrantLock-vs-Synchronized" class="headerlink" title="二、 ReentrantLock vs Synchronized"></a>二、 ReentrantLock vs Synchronized</h3><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>特性</td>
<td>Synchronized</td>
<td>ReentrantLock</td>
</tr>
<tr>
<td><strong>实现层面</strong></td>
<td>JVM 层面（关键字），由 C++ 实现。</td>
<td>JDK 层面（API），纯 Java 编写。</td>
</tr>
<tr>
<td><strong>锁的释放</strong></td>
<td>代码执行完毕或异常时<strong>自动</strong>释放。</td>
<td>必须在 finally 块中<strong>手动</strong>释放，否则易死锁。</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>较低。不可中断，不支持超时。</td>
<td>较高。支持 tryLock()、lockInterruptibly()。</td>
</tr>
<tr>
<td><strong>条件变量</strong></td>
<td>只有 1 个（wait&#x2F;notify）。</td>
<td>支持多个 Condition（精确唤醒某些线程）。</td>
</tr>
<tr>
<td><strong>公平性</strong></td>
<td>只支持<strong>非公平锁</strong>。</td>
<td>支持<strong>公平锁</strong>和<strong>非公平锁</strong>（默认）。</td>
</tr>
</tbody></table>
<hr>
<h3 id="三、-公平锁与非公平锁"><a href="#三、-公平锁与非公平锁" class="headerlink" title="三、 公平锁与非公平锁"></a>三、 公平锁与非公平锁</h3><p>这是 ReentrantLock 的一个重要特性：</p>
<ul>
<li><p><strong>公平锁 (Fair Lock)</strong>：</p>
<ul>
<li><strong>机制</strong>：严格按照线程等待的先后顺序（FIFO）获取锁。</li>
<li><strong>优点</strong>：不会产生“线程饥饿”现象。</li>
<li><strong>缺点</strong>：吞吐量低，因为频繁的线程唤醒和上下文切换开销大。</li>
</ul>
</li>
<li><p><strong>非公平锁 (Non-fair Lock) - 默认</strong>：</p>
<ul>
<li><strong>机制</strong>：线程尝试获取锁时，不检查队列，直接尝试 CAS 抢占。抢不到再进队列。</li>
<li><strong>优点</strong>：吞吐量高。如果一个线程刚释放锁，另一个线程正好来申请，它可以直接使用，省去了唤醒队列线程的时间。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="四、-实际项目中的应用场景"><a href="#四、-实际项目中的应用场景" class="headerlink" title="四、 实际项目中的应用场景"></a>四、 实际项目中的应用场景</h3><ol>
<li><p><strong>使用 synchronized 的场景</strong>：如果是简单的线程同步（如对一个计数器自增），我优先选 synchronized。因为 Java 1.6 后引入了偏向锁、轻量级锁，在低竞争下性能极佳，且代码简洁，不会忘记释放锁。</p>
</li>
<li><p><strong>使用 ReentrantLock 的场景</strong>：</p>
<ul>
<li><strong>超时控制</strong>：比如在请求 AI 模型接口（FastAPI 后端）同步数据时，如果锁等待超过 3 秒还没拿到，我希望记录日志并返回失败，此时 tryLock(3, TimeUnit.SECONDS) 非常有用。</li>
<li><strong>多条件唤醒</strong>：在实现生产者-消费者模型处理海量订单数据时，可以用两个 Condition（notFull, notEmpty）来精准唤醒生产线程或消费线程，避免 notifyAll 带来的“惊群效应”。</li>
</ul>
</li>
</ol>

      </div>
    </div>
  </div>

  <aside class="post-toc-container">
    <div class="post-toc-header">Directory</div>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E8%A7%A3%E9%87%8A-Java-%E4%B8%AD%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%EF%BC%8C%E5%B9%B6%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E-ArrayList-%E5%92%8C-LinkedList-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%85%B6%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">请解释 Java 中集合框架的层次结构，并举例说明 ArrayList 和 LinkedList 的区别及其适用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81-Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-text">一、 Java 集合框架的层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-ArrayList-%E4%B8%8E-LinkedList-%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AF%B9%E6%AF%94"><span class="toc-text">二、 ArrayList 与 LinkedList 的深度对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Volatile-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9F%E5%AE%83%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%8E-Synchronized-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">什么是 Volatile 关键字？它在多线程环境中的作用是什么？与 Synchronized 的区别是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E4%BB%80%E4%B9%88%E6%98%AF-Volatile-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9F"><span class="toc-text">一、 什么是 Volatile 关键字？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-Volatile-%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%A4%E5%A4%A7%E4%BD%9C%E7%94%A8"><span class="toc-text">二、 Volatile 在多线程中的两大作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81-Volatile-%E4%B8%8E-Synchronized-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">三、 Volatile 与 Synchronized 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">四、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0-ReentrantLock-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%B8%8E-Synchronized-%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%88%E5%8C%85%E6%8B%AC%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%89"><span class="toc-text">描述 ReentrantLock 的实现原理，以及它与 Synchronized 的比较（包括公平锁和非公平锁）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81-ReentrantLock-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">一、 ReentrantLock 的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-ReentrantLock-vs-Synchronized"><span class="toc-text">二、 ReentrantLock vs Synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81-%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-text">三、 公平锁与非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">四、 实际项目中的应用场景</span></a></li></ol></li></ol>
  </aside>
</div>


  <div class="post-nav" style="margin-top: 24px; display: flex; justify-content: space-between;">
    
    
      <a href="/2025/12/27/AI%E5%8A%A9%E6%89%8B%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/" class="next">
        AI助手聊天系统项目文档 &raquo;
      </a>
    
  </div>


<script>
document.addEventListener('DOMContentLoaded', function() {
  const tocLinks = document.querySelectorAll('.toc-link');
  const headings = Array.from(document.querySelectorAll('.post-content h1, .post-content h2, .post-content h3'));

  if (tocLinks.length > 0 && headings.length > 0) {
    const observerOptions = {
      root: null,
      rootMargin: '-100px 0px -66% 0px',
      threshold: 0
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const id = entry.target.getAttribute('id');
          // Remove active class from all links
          tocLinks.forEach(link => link.classList.remove('active'));
          // Add active class to corresponding link
          const activeLink = document.querySelector(`.toc-link[href="#${id}"]`);
          if (activeLink) {
            activeLink.classList.add('active');
            // Optional: scroll TOC to active link if needed
          }
        }
      });
    }, observerOptions);

    headings.forEach(heading => observer.observe(heading));
  }
});
</script>

    </main>
  </div>
  
  <footer class="footer">
  <div class="footer-inner">
    
      &copy; 2026 Morris
    
    
    

    
    <br>
      
        Powered by <a href="https://lovelxh95.github.io/" target="_blank">Morris</a> | Theme - <a href="https://github.com/lovelxh95" target="_blank">gtihub_class</a>
      
    
  </div>
</footer>

  <script src="/js/copy-code.js"></script>
</body>
</html>
