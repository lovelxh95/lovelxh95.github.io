<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java开发面试（1）</title>
      <link href="/2026/01/03/Java%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%EF%BC%881%EF%BC%89/"/>
      <url>/2026/01/03/Java%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="请解释-Java-中集合框架的层次结构，并举例说明-ArrayList-和-LinkedList-的区别及其适用场景"><a href="#请解释-Java-中集合框架的层次结构，并举例说明-ArrayList-和-LinkedList-的区别及其适用场景" class="headerlink" title="请解释 Java 中集合框架的层次结构，并举例说明 ArrayList 和 LinkedList 的区别及其适用场景"></a>请解释 Java 中集合框架的层次结构，并举例说明 ArrayList 和 LinkedList 的区别及其适用场景</h2><h3 id="一、-Java-集合框架的层次结构"><a href="#一、-Java-集合框架的层次结构" class="headerlink" title="一、 Java 集合框架的层次结构"></a>一、 Java 集合框架的层次结构</h3><p>Java 集合框架主要由两大根接口组成：<code>Collection</code> 和 <code>Map</code>。</p><ol><li><strong>Collection 接口</strong>：存储对象的集合。<ul><li><strong>List (有序、可重复)</strong>：<ul><li>ArrayList：基于动态数组实现。</li><li>LinkedList：基于双向链表实现。</li><li>Vector：线程安全（古老，不推荐使用）。</li></ul></li><li><strong>Set (无序、唯一)</strong>：<ul><li>HashSet：基于 HashMap 实现，速度快。</li><li>TreeSet：支持自然排序或定制排序。</li><li>LinkedHashSet：维护插入顺序。</li></ul></li><li><strong>Queue (队列)</strong>：<ul><li>PriorityQueue：优先级队列。</li><li>Deque：双端队列（LinkedList 也实现了该接口）。</li></ul></li></ul></li><li><strong>Map 接口</strong>：存储键值对（Key-Value）。<ul><li>HashMap：最常用，高效。</li><li>TreeMap：按 Key 排序。</li><li>ConcurrentHashMap：线程安全，常用于高并发场景。</li></ul></li></ol><hr><h3 id="二、-ArrayList-与-LinkedList-的深度对比"><a href="#二、-ArrayList-与-LinkedList-的深度对比" class="headerlink" title="二、 ArrayList 与 LinkedList 的深度对比"></a>二、 ArrayList 与 LinkedList 的深度对比</h3><p>这两者都实现了 List 接口，但在底层数据结构和性能表现上有本质区别：</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>特性</td><td>ArrayList</td><td>LinkedList</td></tr><tr><td><strong>底层结构</strong></td><td><strong>动态数组</strong>（连续内存空间）</td><td><strong>双向链表</strong>（非连续内存空间）</td></tr><tr><td><strong>随机访问 (get&#x2F;set)</strong></td><td><strong>极快 (<br><br>        <code>O(1)O(1)O(1)</code><br>      <br><br>)</strong>：通过下标直接定位。</td><td><strong>慢 (<br><br>        <code>O(n)O(n)O(n)</code><br>      <br><br>)</strong>：需要从头或尾遍历。</td></tr><tr><td><strong>插入&#x2F;删除 (add&#x2F;remove)</strong></td><td><strong>较慢 (<br><br>        <code>O(n)O(n)O(n)</code><br>      <br><br>)</strong>：涉及数组扩容和元素移动。</td><td><strong>快 (<br><br>        <code>O(1)O(1)O(1)</code><br>      <br><br>)</strong>：仅需修改指针（若已定位到位置）。</td></tr><tr><td><strong>内存占用</strong></td><td>较小：主要浪费在预留的末尾空间。</td><td>较大：每个节点都要存储前驱和后继指针。</td></tr><tr><td><strong>线程安全</strong></td><td>线程不安全</td><td>线程不安全</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><hr><h2 id="什么是-Volatile-关键字？它在多线程环境中的作用是什么？与-Synchronized-的区别是什么？"><a href="#什么是-Volatile-关键字？它在多线程环境中的作用是什么？与-Synchronized-的区别是什么？" class="headerlink" title="什么是 Volatile 关键字？它在多线程环境中的作用是什么？与 Synchronized 的区别是什么？"></a>什么是 Volatile 关键字？它在多线程环境中的作用是什么？与 Synchronized 的区别是什么？</h2><h3 id="一、-什么是-Volatile-关键字？"><a href="#一、-什么是-Volatile-关键字？" class="headerlink" title="一、 什么是 Volatile 关键字？"></a>一、 什么是 Volatile 关键字？</h3><p><code>volatile</code> 是 Java 提供的一种<strong>轻量级的同步机制</strong>。它的核心作用是确保变量的修改对所有线程都是可见的，并防止指令重排序。</p><p>在 Java 内存模型（JMM）中，每个线程有自己的工作内存（私有缓存），线程操作变量时会先从主内存拷贝一份。如果一个变量没被 <code>volatile</code> 修饰，线程修改完后可能不会立即写回主内存，导致其他线程读到的是旧值。</p><hr><h3 id="二、-Volatile-在多线程中的两大作用"><a href="#二、-Volatile-在多线程中的两大作用" class="headerlink" title="二、 Volatile 在多线程中的两大作用"></a>二、 Volatile 在多线程中的两大作用</h3><ol><li><p><strong>保证内存可见性 (Visibility)</strong>：</p><ul><li>一旦一个变量被声明为 volatile，任何线程对它的修改都会立即刷新到主内存中；同时，其他线程在读取该变量时，会强制从主内存中读取最新值，而不是从自己的工作内存。</li></ul></li><li><p><strong>禁止指令重排序 (Ordering)</strong>：</p><ul><li>为了优化性能，编译器和处理器可能会对代码指令进行乱序执行。volatile 通过插入“内存屏障（Memory Barrier）”来防止这种重排序。</li><li><strong>典型应用：</strong> 单例模式中的 <strong>DCL（双重检查锁）</strong>。如果不加 volatile，在对象初始化时，由于重排序，另一个线程可能会拿到一个“尚未完全初始化完成”的对象引用。</li></ul></li></ol><h3 id="三、-Volatile-与-Synchronized-的区别"><a href="#三、-Volatile-与-Synchronized-的区别" class="headerlink" title="三、 Volatile 与 Synchronized 的区别"></a>三、 Volatile 与 Synchronized 的区别</h3><p>虽然两者都用于并发编程，但它们有本质的不同：</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>特性</td><td>Volatile</td><td>Synchronized</td></tr><tr><td><strong>性质</strong></td><td>变量修饰符，轻量级。</td><td>关键字，可修饰方法或代码块，重量级。</td></tr><tr><td><strong>原子性</strong></td><td><strong>不保证原子性</strong>（如 i++ 操作无法保证正确）。</td><td><strong>保证原子性</strong>（同一时间只有一个线程执行）。</td></tr><tr><td><strong>可见性</strong></td><td>保证可见性。</td><td>保证可见性（解锁前必须刷新回主内存）。</td></tr><tr><td><strong>阻塞</strong></td><td><strong>不会</strong>造成线程阻塞，性能高。</td><td><strong>会</strong>造成线程阻塞，涉及上下文切换，性能相对较低。</td></tr><tr><td><strong>有序性</strong></td><td>保证有序性（禁止重排序）。</td><td>保证有序性（通过互斥保证单线程执行）。</td></tr></tbody></table><hr><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>在实际开发中（如我简历中提到的广告引擎维护）：</p><ul><li><strong>使用 volatile 的场景：</strong> 当你需要一个简单的“状态标记位”（如 isReady, isShutdown），且该变量的操作不依赖当前值（即不需要 i++ 这种操作）时，volatile 是性能最优的选择。</li><li><strong>使用 synchronized 的场景：</strong> 当你需要执行复杂的复合操作，或者需要保证操作的“原子性”时（例如在“问卷系统”中扣减优惠券额度、更新计数器），必须使用 synchronized 或 ReentrantLock。</li></ul><p><strong>总结：</strong> volatile 解决了“看得到”的问题，而 synchronized 解决了“写得准”的问题。在追求高并发性能时，我会优先考虑 volatile 或 Atomic 原子类，只有在必要时才使用较重的锁机制。</p><hr><h2 id="描述-ReentrantLock-的实现原理，以及它与-Synchronized-的比较（包括公平锁和非公平锁）"><a href="#描述-ReentrantLock-的实现原理，以及它与-Synchronized-的比较（包括公平锁和非公平锁）" class="headerlink" title="描述 ReentrantLock 的实现原理，以及它与 Synchronized 的比较（包括公平锁和非公平锁）"></a>描述 ReentrantLock 的实现原理，以及它与 Synchronized 的比较（包括公平锁和非公平锁）</h2><h3 id="一、-ReentrantLock-的实现原理"><a href="#一、-ReentrantLock-的实现原理" class="headerlink" title="一、 ReentrantLock 的实现原理"></a>一、 ReentrantLock 的实现原理</h3><p>ReentrantLock 的核心是基于 <strong>AQS（AbstractQueuedSynchronizer，抽象队列同步器）</strong> 实现的。</p><ol><li><p><strong>状态管理（state）</strong>：AQS 内部维护一个 volatile 修饰的 state 变量。</p><ul><li>当 state &#x3D; 0 时，表示锁未被占用。</li><li>线程尝试通过 <strong>CAS（Compare-And-Swap）</strong> 操作将 state 从 0 修改为 1 来获取锁。</li></ul></li><li><p><strong>重入性实现</strong>：</p><ul><li>如果获取锁的线程是“当前占有锁的线程”，则 state 加 1，这就是“可重入”的体现。</li><li>释放锁时，state 减 1，直到 state &#x3D; 0 时锁才完全释放。</li></ul></li><li><p><strong>等待队列（CLH 变体）</strong>：</p><ul><li>如果 CAS 失败（锁已被占用），线程会被封装成一个 Node 节点，进入一个双向同步队列中挂起（LockSupport.park）。</li><li>当持有锁的线程释放锁后，会唤醒队列中头节点的下一个节点尝试获取锁。</li></ul></li></ol><hr><h3 id="二、-ReentrantLock-vs-Synchronized"><a href="#二、-ReentrantLock-vs-Synchronized" class="headerlink" title="二、 ReentrantLock vs Synchronized"></a>二、 ReentrantLock vs Synchronized</h3><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>特性</td><td>Synchronized</td><td>ReentrantLock</td></tr><tr><td><strong>实现层面</strong></td><td>JVM 层面（关键字），由 C++ 实现。</td><td>JDK 层面（API），纯 Java 编写。</td></tr><tr><td><strong>锁的释放</strong></td><td>代码执行完毕或异常时<strong>自动</strong>释放。</td><td>必须在 finally 块中<strong>手动</strong>释放，否则易死锁。</td></tr><tr><td><strong>灵活性</strong></td><td>较低。不可中断，不支持超时。</td><td>较高。支持 tryLock()、lockInterruptibly()。</td></tr><tr><td><strong>条件变量</strong></td><td>只有 1 个（wait&#x2F;notify）。</td><td>支持多个 Condition（精确唤醒某些线程）。</td></tr><tr><td><strong>公平性</strong></td><td>只支持<strong>非公平锁</strong>。</td><td>支持<strong>公平锁</strong>和<strong>非公平锁</strong>（默认）。</td></tr></tbody></table><hr><h3 id="三、-公平锁与非公平锁"><a href="#三、-公平锁与非公平锁" class="headerlink" title="三、 公平锁与非公平锁"></a>三、 公平锁与非公平锁</h3><p>这是 ReentrantLock 的一个重要特性：</p><ul><li><p><strong>公平锁 (Fair Lock)</strong>：</p><ul><li><strong>机制</strong>：严格按照线程等待的先后顺序（FIFO）获取锁。</li><li><strong>优点</strong>：不会产生“线程饥饿”现象。</li><li><strong>缺点</strong>：吞吐量低，因为频繁的线程唤醒和上下文切换开销大。</li></ul></li><li><p><strong>非公平锁 (Non-fair Lock) - 默认</strong>：</p><ul><li><strong>机制</strong>：线程尝试获取锁时，不检查队列，直接尝试 CAS 抢占。抢不到再进队列。</li><li><strong>优点</strong>：吞吐量高。如果一个线程刚释放锁，另一个线程正好来申请，它可以直接使用，省去了唤醒队列线程的时间。</li></ul></li></ul><hr><h3 id="四、-实际项目中的应用场景"><a href="#四、-实际项目中的应用场景" class="headerlink" title="四、 实际项目中的应用场景"></a>四、 实际项目中的应用场景</h3><ol><li><p><strong>使用 synchronized 的场景</strong>：如果是简单的线程同步（如对一个计数器自增），我优先选 synchronized。因为 Java 1.6 后引入了偏向锁、轻量级锁，在低竞争下性能极佳，且代码简洁，不会忘记释放锁。</p></li><li><p><strong>使用 ReentrantLock 的场景</strong>：</p><ul><li><strong>超时控制</strong>：比如在请求 AI 模型接口（FastAPI 后端）同步数据时，如果锁等待超过 3 秒还没拿到，我希望记录日志并返回失败，此时 tryLock(3, TimeUnit.SECONDS) 非常有用。</li><li><strong>多条件唤醒</strong>：在实现生产者-消费者模型处理海量订单数据时，可以用两个 Condition（notFull, notEmpty）来精准唤醒生产线程或消费线程，避免 notifyAll 带来的“惊群效应”。</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AI助手聊天系统项目文档</title>
      <link href="/2025/12/27/AI%E5%8A%A9%E6%89%8B%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/"/>
      <url>/2025/12/27/AI%E5%8A%A9%E6%89%8B%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="AI助手聊天系统项目文档"><a href="#AI助手聊天系统项目文档" class="headerlink" title="AI助手聊天系统项目文档"></a>AI助手聊天系统项目文档</h1><h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><p>AI助手聊天系统是一个基于FastAPI和Vue.js的现代化AI对话平台，支持多模型切换、实时流式对话传输和对话历史管理功能。用户可以通过该系统与各种AI模型进行交互，系统会自动保存对话历史，方便用户随时查看和继续之前的对话。</p><h2 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h2><ul><li>🤖 多AI模型支持：系统支持多种AI模型切换，包括GLM-4.5、Qwen3、Kimi等</li><li>💬 实时流式对话：采用流式传输技术，提供接近实时的对话体验</li><li>📝 对话历史管理：自动保存对话记录，支持按时间查看历史对话</li><li>👤 用户管理系统：完整的用户注册、登录和权限管理功能</li><li>🎨 现代化界面：响应式设计，适配不同设备屏幕</li><li>🔒 数据安全：用户数据隔离，确保隐私安全</li></ul><h2 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h2><h3 id="后端技术栈"><a href="#后端技术栈" class="headerlink" title="后端技术栈"></a>后端技术栈</h3><ul><li><strong>FastAPI</strong>：现代化、快速的Python Web框架，提供异步处理能力</li><li><strong>MySQL</strong>：关系型数据库，用于持久化存储用户信息和对话记录</li><li><strong>PyMySQL</strong>：Python MySQL数据库连接库</li><li><strong>HTTPX</strong>：异步HTTP客户端，用于与AI模型API通信</li></ul><h3 id="前端技术栈"><a href="#前端技术栈" class="headerlink" title="前端技术栈"></a>前端技术栈</h3><ul><li><strong>Vue.js 3</strong>：渐进式JavaScript框架，构建用户界面</li><li><strong>Element Plus</strong>：基于Vue 3的组件库，提供丰富的UI组件</li><li><strong>原生HTML&#x2F;CSS&#x2F;JavaScript</strong>：实现基础页面结构和样式</li></ul><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>确保系统已安装以下依赖：</p><ul><li>Python 3.12</li><li>MySQL 8</li><li>Git</li></ul><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol><li>克隆项目代码：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/lovelxh95/ai-helper.git</span><br><span class="line"><span class="built_in">cd</span> ai-helper</span><br></pre></td></tr></table></figure><ol start="2"><li>安装项目依赖：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><ol start="3"><li>配置数据库：</li></ol><p>创建MySQL数据库并执行初始化脚本：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source database.sql</span><br></pre></td></tr></table></figure><ol start="4"><li>配置数据库连接信息：</li></ol><p>修改 <a href="file:///D:/CodeProject/PycharmProjects/ai-helper/config.py">config.py</a> 文件中的数据库配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MySQL_CONFIG = &#123;</span><br><span class="line">    <span class="string">&#x27;host&#x27;</span>: <span class="string">&#x27;your_host&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;port&#x27;</span>: <span class="number">3306</span>,</span><br><span class="line">    <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;your_username&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;your_password&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;db&#x27;</span>: <span class="string">&#x27;ai&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;charset&#x27;</span>: <span class="string">&#x27;utf8mb4&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>启动服务：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python main.py</span><br></pre></td></tr></table></figure><p>服务将在 <a href="http://localhost:8000/">http://localhost:8000</a> 启动。</p><p><img src="https://camo.githubusercontent.com/5c8d43bc19cdb0bb9d12d654b019a3e3a3d68c8bc0a55588924f729a2e62ff5e/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34343834333733332f313735333935343932363839352d37653261616232332d336336382d343039322d396233642d6435616531643365623765642e706e67"></p><ol start="6"><li>设置服务商</li></ol><ul><li>访问<a href="http://localhost:8000/admin">http://localhost:8000/admin</a></li><li>设置服务商</li></ul><p><img src="https://camo.githubusercontent.com/204cb536ad32bf64ffa283a776985a689d591723c792e7519c87d9b6d67720e6/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34343834333733332f313735333935353230363533312d33373431613830382d313532662d343338662d623866322d3064396631353366343864382e706e67"></p><ul><li>设置模型</li></ul><p><img src="https://camo.githubusercontent.com/c10a4f72a31c247d244d01b9560aaee4e993f30f503b08a2cb3d82b0d439a78f/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34343834333733332f313735333935353232343235342d33373566356336302d393661302d343536622d386336632d6633393836663630343636622e706e67"></p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="用户表-users"><a href="#用户表-users" class="headerlink" title="用户表 (users)"></a>用户表 (users)</h3><p>存储用户基本信息和权限信息。</p><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>INT (主键)</td><td>用户ID</td></tr><tr><td>username</td><td>VARCHAR(50)</td><td>用户名（唯一）</td></tr><tr><td>password</td><td>VARCHAR(255)</td><td>密码哈希值</td></tr><tr><td>avatar</td><td>VARCHAR(500)</td><td>用户头像URL</td></tr><tr><td>create_time</td><td>TIMESTAMP</td><td>创建时间</td></tr><tr><td>last_login</td><td>TIMESTAMP</td><td>最后登录时间</td></tr><tr><td>status</td><td>TINYINT</td><td>用户状态：1-正常，0-禁用</td></tr><tr><td>is_admin</td><td>TINYINT</td><td>是否为管理员：1-是，0-否</td></tr></tbody></table><h3 id="API服务商表-api-providers"><a href="#API服务商表-api-providers" class="headerlink" title="API服务商表 (api_providers)"></a>API服务商表 (api_providers)</h3><p>存储AI模型API服务商信息。</p><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>INT (主键)</td><td>服务商ID</td></tr><tr><td>name</td><td>VARCHAR(100)</td><td>服务商名称</td></tr><tr><td>base_url</td><td>VARCHAR(500)</td><td>API基础URL</td></tr><tr><td>api_key</td><td>VARCHAR(500)</td><td>API密钥</td></tr><tr><td>description</td><td>TEXT</td><td>服务商描述</td></tr><tr><td>status</td><td>TINYINT</td><td>状态：1-启用，0-禁用</td></tr><tr><td>create_time</td><td>TIMESTAMP</td><td>创建时间</td></tr><tr><td>update_time</td><td>TIMESTAMP</td><td>更新时间</td></tr></tbody></table><h3 id="模型配置表-model-configs"><a href="#模型配置表-model-configs" class="headerlink" title="模型配置表 (model_configs)"></a>模型配置表 (model_configs)</h3><p>存储AI模型配置信息。</p><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>INT (主键)</td><td>模型配置ID</td></tr><tr><td>provider_id</td><td>INT</td><td>服务商ID（外键）</td></tr><tr><td>model_id</td><td>VARCHAR(200)</td><td>模型ID</td></tr><tr><td>model_name</td><td>VARCHAR(200)</td><td>模型显示名称</td></tr><tr><td>description</td><td>TEXT</td><td>模型描述</td></tr><tr><td>max_tokens</td><td>INT</td><td>最大token数</td></tr><tr><td>status</td><td>TINYINT</td><td>状态：1-启用，0-禁用</td></tr><tr><td>sort_order</td><td>INT</td><td>排序权重</td></tr><tr><td>create_time</td><td>TIMESTAMP</td><td>创建时间</td></tr><tr><td>update_time</td><td>TIMESTAMP</td><td>更新时间</td></tr></tbody></table><h3 id="会话表-chat-sessions"><a href="#会话表-chat-sessions" class="headerlink" title="会话表 (chat_sessions)"></a>会话表 (chat_sessions)</h3><p>管理用户对话会话。</p><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>INT (主键)</td><td>会话ID</td></tr><tr><td>session_id</td><td>VARCHAR(100)</td><td>会话标识（唯一）</td></tr><tr><td>user_id</td><td>INT</td><td>用户ID（外键）</td></tr><tr><td>title</td><td>VARCHAR(200)</td><td>会话标题</td></tr><tr><td>model_id</td><td>VARCHAR(100)</td><td>当前使用的模型ID</td></tr><tr><td>create_time</td><td>TIMESTAMP</td><td>创建时间</td></tr><tr><td>update_time</td><td>TIMESTAMP</td><td>更新时间</td></tr><tr><td>is_active</td><td>TINYINT</td><td>是否活跃：1-活跃，0-已结束</td></tr></tbody></table><h3 id="对话消息表-ai-chat-messages"><a href="#对话消息表-ai-chat-messages" class="headerlink" title="对话消息表 (ai_chat_messages)"></a>对话消息表 (ai_chat_messages)</h3><p>存储具体的对话消息记录。</p><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>INT (主键)</td><td>消息ID</td></tr><tr><td>session_id</td><td>VARCHAR(100)</td><td>会话ID（外键）</td></tr><tr><td>user_id</td><td>INT</td><td>用户ID（外键）</td></tr><tr><td>role</td><td>ENUM(‘user’, ‘assistant’)</td><td>消息角色：user-用户，assistant-助手</td></tr><tr><td>content</td><td>TEXT</td><td>消息内容</td></tr><tr><td>create_time</td><td>TIMESTAMP</td><td>创建时间</td></tr></tbody></table><h2 id="API接口说明"><a href="#API接口说明" class="headerlink" title="API接口说明"></a>API接口说明</h2><h3 id="用户认证相关"><a href="#用户认证相关" class="headerlink" title="用户认证相关"></a>用户认证相关</h3><ul><li><code>POST /api/register</code> - 用户注册</li><li><code>POST /api/login</code> - 用户登录</li></ul><h3 id="聊天功能相关"><a href="#聊天功能相关" class="headerlink" title="聊天功能相关"></a>聊天功能相关</h3><ul><li><code>GET /api/models</code> - 获取可用模型列表</li><li><code>POST /api/chat/stream</code> - 发送消息（流式响应）</li><li><code>GET /api/chat/history</code> - 获取对话历史</li><li><code>POST /api/chat/history/time-range</code> - 根据时间范围筛选对话历史</li><li><code>DELETE /api/chat/session/&#123;session_id&#125;</code> - 删除对话会话</li></ul><h3 id="用户管理相关"><a href="#用户管理相关" class="headerlink" title="用户管理相关"></a>用户管理相关</h3><ul><li><code>GET /api/user/info</code> - 获取用户信息</li><li><code>POST /api/user/avatar</code> - 上传用户头像</li></ul><h2 id="前端界面介绍"><a href="#前端界面介绍" class="headerlink" title="前端界面介绍"></a>前端界面介绍</h2><h3 id="登录-注册页面"><a href="#登录-注册页面" class="headerlink" title="登录&#x2F;注册页面"></a>登录&#x2F;注册页面</h3><p>用户首次使用系统需要注册账号，已有账号的用户可以直接登录。</p><h3 id="主聊天界面"><a href="#主聊天界面" class="headerlink" title="主聊天界面"></a>主聊天界面</h3><p>登录成功后进入主聊天界面，包含以下主要区域：</p><ol><li><strong>侧边栏</strong>：显示对话历史记录，支持新建对话和删除对话</li><li><strong>聊天区域</strong>：显示对话内容，区分用户消息和AI回复</li><li><strong>输入区域</strong>：用户输入消息的地方，支持快捷键发送</li></ol><p><img src="https://camo.githubusercontent.com/067f7e01ad0223ef6dad773312dbea3d84e772811dac51264825320fe82ba0ae/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34343834333733332f313735333936393038343139362d63313037363161642d373461362d343436662d393439392d6436386561633738323632642e706e67"></p><h3 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h3><p>系统支持多种AI模型，用户可以通过下拉菜单切换不同的AI模型。</p><p><img src="https://camo.githubusercontent.com/aa914d2883e34129d2395032b84708b598f2f7bb0df8091d0695ed6ac9524fa8/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34343834333733332f313735333935353239333730372d35643132626162642d643265372d346665382d383430382d6163626262623365633232632e706e67"></p><h3 id="时间范围筛选功能"><a href="#时间范围筛选功能" class="headerlink" title="时间范围筛选功能"></a>时间范围筛选功能</h3><p>系统支持根据时间范围筛选对话历史记录：</p><ol><li>在侧边栏的对话历史区域上方有时间范围选择器</li><li>选择开始日期和结束日期后，系统会自动筛选该时间段内的对话</li><li>点击”清除筛选”按钮可恢复显示所有对话历史</li></ol><p><img src="https://camo.githubusercontent.com/18de0aebd92c98e45dd3a9c9104167641030a5aa683d7523c42d716ed033baa8/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34343834333733332f313735333936393033323133392d62636237366436652d366134392d346531312d383463362d3736333761373735336633352e706e67"></p><p><img src="https://camo.githubusercontent.com/fb1db364c5b759e7b5e2e450502d51450d81de3e7bc07dac2119724908f920cf/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34343834333733332f313735333936393034343134332d35363836343263662d343736642d346435302d383033352d3063356261306138663866612e706e67"></p><p><img src="https://camo.githubusercontent.com/b2390ed04234ed6d4c62c6894a28c423e2dc9cde76240463c95801b8c2399c43/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34343834333733332f313735333936393035343936372d34313365363561642d326539612d343964632d626564632d6237633565646233353266632e706e67"></p><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><ol><li><strong>注册&#x2F;登录</strong>：首次使用需要注册账号，之后可使用注册的账号登录系统</li><li><strong>开始对话</strong>：登录后点击”新建对话”按钮开始与AI聊天</li><li><strong>切换模型</strong>：在聊天界面右上角选择不同的AI模型</li><li><strong>查看历史</strong>：左侧边栏显示所有对话历史，点击可查看历史对话</li><li><strong>时间筛选</strong>：使用侧边栏顶部的时间范围选择器筛选特定时间段的对话</li><li><strong>快捷键操作</strong>：使用 Ctrl+Enter 快速发送消息</li></ol><p><img src="https://camo.githubusercontent.com/e13702e8933c26dd00e384a4e04ebf86c9d0d5212270f364c1c7a2667a22c75e/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34343834333733332f313735333936393131363434322d34646665636130372d393332392d343062332d393537662d3631383137306261313535322e706e67"></p><h2 id="支持的AI模型"><a href="#支持的AI模型" class="headerlink" title="支持的AI模型"></a>支持的AI模型</h2><ul><li>管理员可以设置支持 openai 格式的</li></ul><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ai-helper/</span><br><span class="line">├── static/                 # 静态资源文件</span><br><span class="line">│   ├── index.html          # 主页面</span><br><span class="line">│   ├── admin.html          # 管理员页面</span><br><span class="line">│   ├── script.js           # 主页面JavaScript逻辑</span><br><span class="line">│   ├── admin.js            # 管理员页面JavaScript逻辑</span><br><span class="line">│   └── style.css           # 样式文件</span><br><span class="line">├── main.py                 # 后端主程序</span><br><span class="line">├── config.py               # 配置文件</span><br><span class="line">├── database.sql            # 数据库初始化脚本</span><br><span class="line">├── requirements.txt        # 项目依赖</span><br><span class="line">├── README.md               # 项目说明文档</span><br><span class="line">└── 实操题.md               # 实操题目要求</span><br></pre></td></tr></table></figure><p><img src="https://camo.githubusercontent.com/0372398dffd43cbfdd6f2e60b20f3cc046b8f674fbcec027040cc75ea40b99cc/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34343834333733332f313735333935353436393533392d62383466656231652d613565622d343333612d393437352d6535616330333933376235392e706e67"></p>]]></content>
      
      
      <categories>
          
          <category> fastapi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kmp算法实现</title>
      <link href="/2025/12/15/kmp%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2025/12/15/kmp%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="下面是kmp算法的具体实现"><a href="#下面是kmp算法的具体实现" class="headerlink" title="下面是kmp算法的具体实现"></a>下面是kmp算法的具体实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">nextArray</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pattern, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* next = <span class="keyword">new</span> <span class="type">int</span>[m];</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; m - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || pattern[j] == pattern[k]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">            next[j] = k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">nextValueArray</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pattern, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* nextVal = <span class="keyword">new</span> <span class="type">int</span>[m];</span><br><span class="line">    nextVal[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; m - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || pattern[j] == pattern[k]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">            <span class="keyword">if</span> (pattern[j] != pattern[k]) &#123;</span><br><span class="line">                nextVal[j] = k;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nextVal[j] = nextVal[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = nextVal[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMP</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text, <span class="type">const</span> <span class="type">char</span>* pattern)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(text);</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line">    <span class="type">int</span>* next = <span class="built_in">nextArray</span>(pattern, m);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || text[i] == pattern[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] next;</span><br><span class="line">    <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - j; <span class="comment">// 匹配成功，返回起始位置</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 匹配失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* text = <span class="string">&quot;ababcabcacbab&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pattern = <span class="string">&quot;abcac&quot;</span>;</span><br><span class="line">    <span class="type">int</span> position = <span class="built_in">KMP</span>(text, pattern);</span><br><span class="line">    <span class="keyword">if</span> (position != <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Pattern found at index: &quot;</span> &lt;&lt; position &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Pattern not found.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/image_1766812462847.png" alt="image_1766812462847.png"></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的性质</title>
      <link href="/2025/11/17/%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8/"/>
      <url>/2025/11/17/%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一、-树的基本定义和性质"><a href="#一、-树的基本定义和性质" class="headerlink" title="一、 树的基本定义和性质"></a>一、 树的基本定义和性质</h1><h2 id="1-树的逻辑结构定义"><a href="#1-树的逻辑结构定义" class="headerlink" title="1. 树的逻辑结构定义"></a>1. 树的逻辑结构定义</h2><p>树是 n（n &gt;&#x3D; 0）个结点的有限集合。</p><ul><li>当 n&#x3D;0 时，称为空树，这是一种特殊情况。</li><li>在任意一棵非空树中，应满足：有且仅有一个特定的结点称为根结点。</li><li>当 n &gt; 1 时，其余结点可分为 m（m &gt; 0）个互不相交的有限集合 T1, T2, …, Tm，其中每个集合本身又是一棵树，并称为根结点的子树。</li></ul><h2 id="2-二叉树的特点"><a href="#2-二叉树的特点" class="headerlink" title="2. 二叉树的特点"></a>2. 二叉树的特点</h2><p>二叉树是 n（n &gt;&#x3D; 0）个结点的有限集合。</p><ul><li>它或者为空二叉树（n&#x3D;0）。</li><li>或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成，左子树和右子树又分别是一棵二叉树。</li><li>二叉树的特点包括：每个结点至多只有两棵子树。</li><li>左右子树不能颠倒（二叉树是有序树）。</li></ul><h1 id="二、-m-叉树的常见考点性质及其推导"><a href="#二、-m-叉树的常见考点性质及其推导" class="headerlink" title="二、 m 叉树的常见考点性质及其推导"></a>二、 m 叉树的常见考点性质及其推导</h1><p>以下是关于高度为 h 的 m 叉树（m-ary tree）的常见性质：</p><h2 id="1-m-叉树至多拥有的结点数"><a href="#1-m-叉树至多拥有的结点数" class="headerlink" title="1. m 叉树至多拥有的结点数"></a>1. m 叉树至多拥有的结点数</h2><p><strong>性质：</strong> 高度为 h 的 m 叉树至多有 (m^h - 1) &#x2F; (m - 1) 个结点。</p><p><strong>推导：</strong></p><ul><li>这个结论基于每一层结点数最大化（即所有非叶子结点都拥有 m 个孩子）的情况。</li><li>第 1 层有 m^0 个结点。</li><li>第 2 层有 m^1 个结点。</li><li>第 3 层有 m^2 个结点。</li><li>第 h 层有 m^(h-1) 个结点。</li><li>总的结点数是这些层结点数的总和，构成一个等比数列求和：m^0 + m^1 + m^2 + … + m^(h-1)。</li><li>根据等比数列求和公式 a + aq + aq^2 + … + aq^(n-1) &#x3D; a(q^n - 1) &#x2F; (q - 1)（其中 a&#x3D;1, q&#x3D;m, n&#x3D;h），得到最大结点数为 (m^h - 1) &#x2F; (m - 1)。</li></ul><h2 id="2-m-叉树最少拥有的结点数"><a href="#2-m-叉树最少拥有的结点数" class="headerlink" title="2. m 叉树最少拥有的结点数"></a>2. m 叉树最少拥有的结点数</h2><p><strong>性质：</strong> 高度为 h 的 m 叉树至少有 h 个结点。</p><h2 id="3-具有-n-个结点的-m-叉树的最小高度"><a href="#3-具有-n-个结点的-m-叉树的最小高度" class="headerlink" title="3. 具有 n 个结点的 m 叉树的最小高度"></a>3. 具有 n 个结点的 m 叉树的最小高度</h2><p><strong>性质：</strong> 具有 n 个结点的 m 叉树的最小高度为 h_min &#x3D; log_m(n(m - 1) + 1) 向上取整。</p><p><strong>推导过程（基于最大结点数）：</strong></p><ul><li>要找到最小高度，必须假设树的结构是最丰满的（即每层节点尽可能多）。</li><li>确定 n 的范围： 具有 h 层的 m 叉树的结点数 n 必须满足：<br>(m^(h-1) - 1) &#x2F; (m - 1) &lt; n &lt;&#x3D; (m^h - 1) &#x2F; (m - 1)<ul><li>其中，左侧不等式表示 n 必须大于前 h-1 层满 m 叉树的结点总数。</li><li>右侧不等式表示 n 最多是 h 层满 m 叉树的结点总数。</li></ul></li><li>提取 m^h 的关系： 关注右侧不等式 (m^h - 1) &#x2F; (m - 1) &gt;&#x3D; n。<ul><li>变形得到：m^h - 1 &gt;&#x3D; n(m - 1)。</li><li>进一步得到：m^h &gt;&#x3D; n(m - 1) + 1。</li></ul></li><li>提取 m^(h-1) 的关系： 关注左侧不等式 (m^(h-1) - 1) &#x2F; (m - 1) &lt; n。<ul><li>变形得到：m^(h-1) - 1 &lt; n(m - 1)。</li><li>进一步得到：m^(h-1) &lt; n(m - 1) + 1。</li></ul></li><li>合并和取对数： 将两个不等式合并：<br>m^(h-1) &lt; n(m - 1) + 1 &lt;&#x3D; m^h<ul><li>对两侧取以 m 为底的对数（log_m）：<br>h - 1 &lt; log_m(n(m - 1) + 1) &lt;&#x3D; h</li></ul></li><li>结论： 由于 h 必须是一个整数，根据这个关系，最小高度 h_min 等于 log_m(n(m - 1) + 1) 向上取整。</li></ul><h2 id="4-高度为-h、度为-m-的树的最小结点数"><a href="#4-高度为-h、度为-m-的树的最小结点数" class="headerlink" title="4. 高度为 h、度为 m 的树的最小结点数"></a>4. 高度为 h、度为 m 的树的最小结点数</h2><p><strong>性质：</strong> 高度为 h、度为 m 的树至少有 h+m-1 个结点。</p><h1 id="三、-图中的生成树性质"><a href="#三、-图中的生成树性质" class="headerlink" title="三、 图中的生成树性质"></a>三、 图中的生成树性质</h1><p>在图论中，连通图的生成树（spanning tree）具有以下性质：</p><ul><li><strong>存在性：</strong> 只有连通图才有生成树。非连通图只有生成森林。</li><li><strong>边数限制：</strong> 最小生成树的边数等于顶点数 - 1。如果在生成树中砍掉一条边则图将不连通；如果增加一条边则会出现回路。</li><li><strong>最小生成树（MST）的权值：</strong> 最小生成树可能有多个，但所有最小生成树的边的权值之和总是唯一且最小的。</li><li><strong>特殊情况：</strong> 如果一个连通图本身就是一棵树，则其最小生成树就是它本身。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cache替换算法</title>
      <link href="/2025/09/03/Cache%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95/"/>
      <url>/2025/09/03/Cache%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="替换算法汇总"><a href="#替换算法汇总" class="headerlink" title="替换算法汇总"></a>替换算法汇总</h3><table><thead><tr><th>算法</th><th>英文全称</th><th>原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>随机算法</strong></td><td>Random Replacement</td><td>随机选择一个 Cache 块替换</td><td>实现简单，硬件开销小</td><td>未考虑访问模式，命中率低</td><td>对性能要求不高，硬件资源有限的场景</td></tr><tr><td><strong>先进先出算法</strong></td><td>FIFO（First In First Out）</td><td>替换最早进入 Cache 的块</td><td>实现简单，硬件开销小</td><td>未考虑数据访问频率，可能替换热点数据</td><td>嵌入式系统、简单处理器</td></tr><tr><td><strong>最近最少使用算法</strong></td><td>LRU（Least Recently Used）</td><td>替换最近最久未使用的块</td><td>较好地利用时间局部性，命中率高</td><td>实现较复杂，需要额外硬件支持</td><td>通用处理器、对性能要求高的场景</td></tr><tr><td><strong>最不经常使用算法</strong></td><td>LFU（Least Frequently Used）</td><td>替换访问次数最少的块</td><td>适合访问频率差异大的场景</td><td>对访问模式变化不敏感，实现复杂</td><td>特定应用场景，如数据库缓存</td></tr></tbody></table><h3 id="为什么需要-Cache-替换算法？"><a href="#为什么需要-Cache-替换算法？" class="headerlink" title="为什么需要 Cache 替换算法？"></a>为什么需要 Cache 替换算法？</h3><p><strong>Cache（高速缓存）<strong>是一种容量小但速度极快的存储器，位于 CPU 和主内存之间。它的作用是存放主内存中最常被访问的数据的一个副本。当 CPU 需要数据时，它首先检查 Cache。如果数据在 Cache 中（称为</strong>命中, Hit</strong>），CPU 就可以快速获取；如果不在（称为<strong>未命中, Miss</strong>），CPU 就需要从慢速的主内存中读取数据，并将其加载到 Cache 中。</p><p>由于 Cache 的容量远小于主内存，它很快就会被填满。当 Cache 已满，且 CPU 需要加载新的数据时，就必须选择一个已有的数据块（Cache Line）将其丢弃，以便为新数据腾出空间。<strong>Cache 替换算法</strong>就是用来决定“应该丢弃哪个数据块”的策略。一个好的替换算法能够尽可能保留未来最可能被用到的数据，从而提高 Cache 的命中率，提升系统整体性能。</p><h3 id="1-先进先出算法-First-In-First-Out-FIFO"><a href="#1-先进先出算法-First-In-First-Out-FIFO" class="headerlink" title="1. 先进先出算法 (First-In, First-Out, FIFO)"></a>1. 先进先出算法 (First-In, First-Out, FIFO)</h3><h4 id="算法讲解"><a href="#算法讲解" class="headerlink" title="算法讲解"></a>算法讲解</h4><p>FIFO 是最简单的替换算法。它将 Cache 中的数据块视为一个队列。当需要替换时，它会选择<strong>最早进入 Cache 的数据块</strong>进行替换，无论这个数据块最近是否被访问过。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>假设我们的 Cache 有 3 个槽位（Cache Size &#x3D; 3），我们依次请求以下页面序列：</p><p>7, 0, 1, 2, 0, 3, 0, 4</p><table><thead><tr><th>请求页面</th><th>Cache 状态 (从老到新)</th><th>操作</th></tr></thead><tbody><tr><td><strong>7</strong></td><td><code>[7]</code></td><td>Miss, 7 进入</td></tr><tr><td><strong>0</strong></td><td><code>[7, 0]</code></td><td>Miss, 0 进入</td></tr><tr><td><strong>1</strong></td><td><code>[7, 0, 1]</code></td><td>Miss, 1 进入 (Cache 已满)</td></tr><tr><td><strong>2</strong></td><td><code>[0, 1, 2]</code></td><td>Miss, 替换最早进入的<strong>7</strong></td></tr><tr><td><strong>0</strong></td><td><code>[0, 1, 2]</code></td><td><strong>Hit</strong></td></tr><tr><td><strong>3</strong></td><td><code>[1, 2, 3]</code></td><td>Miss, 替换最早进入的<strong>0</strong></td></tr><tr><td><strong>0</strong></td><td><code>[2, 3, 0]</code></td><td>Miss, 替换最早进入的<strong>1</strong></td></tr><tr><td><strong>4</strong></td><td><code>[3, 0, 4]</code></td><td>Miss, 替换最早进入的<strong>2</strong></td></tr></tbody></table><p>在这个例子中，总共发生了 7 次 Miss 和 1 次 Hit。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>实现简单</strong>：只需要一个简单的队列结构即可实现，算法开销非常小。</li><li><strong>理解容易</strong>：逻辑清晰，易于理解和调试。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><strong>性能不佳</strong>：完全不考虑数据的访问模式。一个经常被访问的热点数据，可能会因为进入 Cache 的时间比较早而被无情地替换出去，导致命中率低下。</li><li><strong>存在 Belady 异常</strong>：在某些情况下，增加 Cache 的容量反而可能导致命中率下降。这是 FIFO 算法一个著名的缺陷。</li></ul><hr><h3 id="2-最近最少使用算法-Least-Recently-Used-LRU"><a href="#2-最近最少使用算法-Least-Recently-Used-LRU" class="headerlink" title="2. 最近最少使用算法 (Least Recently Used, LRU)"></a>2. 最近最少使用算法 (Least Recently Used, LRU)</h3><h4 id="算法讲解-1"><a href="#算法讲解-1" class="headerlink" title="算法讲解"></a>算法讲解</h4><p>LRU 算法的核心思想是“如果一个数据在最近一段时间没有被访问到，那么它在将来被访问的可能性也很小”。因此，当需要替换时，LRU 会选择最长时间没有被访问过的数据块进行替换。这个算法基于“时间局部性”原理，即最近被访问的数据很可能在不久的将来再次被访问。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>同样，Cache 有 3 个槽位，请求序列为：</p><p>7, 0, 1, 2, 0, 3, 0, 4</p><table><thead><tr><th>请求页面</th><th>Cache 状态 (从最少使用到最近使用)</th><th>操作</th></tr></thead><tbody><tr><td><strong>7</strong></td><td><code>[7]</code></td><td>Miss, 7 进入</td></tr><tr><td><strong>0</strong></td><td><code>[7, 0]</code></td><td>Miss, 0 进入</td></tr><tr><td><strong>1</strong></td><td><code>[7, 0, 1]</code></td><td>Miss, 1 进入 (Cache 已满)</td></tr><tr><td><strong>2</strong></td><td><code>[0, 1, 2]</code></td><td>Miss, 替换最久未使用的<strong>7</strong></td></tr><tr><td><strong>0</strong></td><td><code>[1, 2, 0]</code></td><td><strong>Hit</strong>, 0 变为最近使用</td></tr><tr><td><strong>3</strong></td><td><code>[2, 0, 3]</code></td><td>Miss, 替换最久未使用的<strong>1</strong></td></tr><tr><td><strong>0</strong></td><td><code>[2, 3, 0]</code></td><td><strong>Hit</strong>, 0 变为最近使用</td></tr><tr><td><strong>4</strong></td><td><code>[3, 0, 4]</code></td><td>Miss, 替换最久未使用的<strong>2</strong></td></tr></tbody></table><p>在这个例子中，总共发生了 6 次 Miss 和 2 次 Hit，性能优于 FIFO。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>性能好</strong>：充分利用了程序访问的“时间局部性”原理，在大多数场景下都有很高的命中率。</li><li><strong>没有 Belady 异常</strong>：增加 Cache 容量总会提高或保持原有的命中率。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li><strong>实现复杂，开销大</strong>：需要跟踪记录每个数据块的访问历史。常见的实现方式是使用一个双向链表和哈希表的组合，每次访问都需要更新链表节点的位置，这在硬件和软件上都有较高的开销。</li></ul><hr><h3 id="3-最不经常使用算法-Least-Frequently-Used-LFU"><a href="#3-最不经常使用算法-Least-Frequently-Used-LFU" class="headerlink" title="3. 最不经常使用算法 (Least Frequently Used, LFU)"></a>3. 最不经常使用算法 (Least Frequently Used, LFU)</h3><h4 id="算法讲解-2"><a href="#算法讲解-2" class="headerlink" title="算法讲解"></a>算法讲解</h4><p>LFU 算法的核心思想是“<strong>如果一个数据在过去一段时间内被访问的次数很少，那么它在将来被访问的可能性也很小</strong>”。因此，当需要替换时，LFU 会选择被访问次数最少的数据块进行替换。如果存在多个访问次数相同的数据块，通常会结合 LRU 策略，替换其中最久未被访问的那个。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>假设 Cache 有 3 个槽位，请求序列为：</p><p>1, 2, 3, 1, 2, 4, 1, 2, 5</p><table><thead><tr><th>请求页面</th><th>Cache 状态 (页面:访问次数)</th><th>操作</th></tr></thead><tbody><tr><td><strong>1</strong></td><td><code>[(1:1)]</code></td><td>Miss</td></tr><tr><td><strong>2</strong></td><td><code>[(1:1), (2:1)]</code></td><td>Miss</td></tr><tr><td><strong>3</strong></td><td><code>[(1:1), (2:1), (3:1)]</code></td><td>Miss (Cache 已满)</td></tr><tr><td><strong>1</strong></td><td><code>[(1:2), (2:1), (3:1)]</code></td><td><strong>Hit</strong>, 1 的计数增加</td></tr><tr><td><strong>2</strong></td><td><code>[(1:2), (2:2), (3:1)]</code></td><td><strong>Hit</strong>, 2 的计数增加</td></tr><tr><td><strong>4</strong></td><td><code>[(1:2), (2:2), (4:1)]</code></td><td>Miss, 替换访问次数最少的<strong>3</strong></td></tr><tr><td><strong>1</strong></td><td><code>[(1:3), (2:2), (4:1)]</code></td><td><strong>Hit</strong>, 1 的计数增加</td></tr><tr><td><strong>2</strong></td><td><code>[(1:3), (2:3), (4:1)]</code></td><td><strong>Hit</strong>, 2 的计数增加</td></tr><tr><td><strong>5</strong></td><td><code>[(1:3), (2:3), (5:1)]</code></td><td>Miss, 替换访问次数最少的<strong>4</strong></td></tr></tbody></table><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>考虑了访问频率</strong>：对于那些具有稳定访问模式、某些数据被长期频繁访问的场景，LFU 的效果可能优于 LRU。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li><strong>实现更复杂</strong>：不仅要记录访问历史，还要维护每个数据块的访问计数值，通常需要使用堆或优先队列等数据结构，开销比 LRU 更大。</li><li><strong>无法适应访问模式的变化</strong>：一个曾经被高频访问但现在不再需要的数据，可能会因为其高计数值而长时间“污染”Cache，无法被及时替换出去。</li><li><strong>新加入的数据块容易被淘汰</strong>：一个新数据刚进入 Cache 时，其访问次数为 1，很容易在下一次替换中被立即淘汰，导致没有机会“成长”为热点数据。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cache映射</title>
      <link href="/2025/09/03/Cache%E6%98%A0%E5%B0%84/"/>
      <url>/2025/09/03/Cache%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Cache基本概念"><a href="#一、Cache基本概念" class="headerlink" title="一、Cache基本概念"></a>一、Cache基本概念</h2><ul><li><strong>定义</strong>：Cache是位于CPU与主存之间的高速缓冲存储器，用于缓解CPU与主存之间的速度差异。</li><li><strong>透明性</strong>：对程序员和编译器而言，Cache是透明的，程序员无需关心其存在与否，但理解Cache机制有助于编写高效程序。</li><li><strong>基本术语</strong>：<ul><li><strong>主存块（Block）</strong>：主存被划分为大小相等的块。</li><li><strong>Cache行（Line）或槽（Slot）</strong>：Cache被划分为与主存块大小相同的行或槽。</li><li><strong>命中（Hit）</strong>：CPU访问的数据在Cache中。</li><li><strong>缺失（Miss）</strong>：CPU访问的数据不在Cache中，需从主存调入。</li></ul></li></ul><h2 id="二、Cache映射方式（Cache-Mapping）"><a href="#二、Cache映射方式（Cache-Mapping）" class="headerlink" title="二、Cache映射方式（Cache Mapping）"></a>二、Cache映射方式（Cache Mapping）</h2><p>Cache映射方式决定了主存块如何映射到Cache行中，主要有三种方式：</p><table><thead><tr><th>映射方式</th><th>特点</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>直接映射（Direct Mapped）</strong></td><td>每个主存块映射到Cache中固定的行</td><td>实现简单、命中时间短、无需考虑替换策略</td><td>不够灵活，易产生冲突缺失，Cache空间利用率低</td></tr><tr><td><strong>全相联映射（Fully Associative）</strong></td><td>每个主存块可映射到Cache任意行</td><td>灵活，冲突缺失为0，命中率高</td><td>实现复杂，需大量比较器，成本高，速度慢</td></tr><tr><td><strong>组相联映射（Set Associative）</strong></td><td>每组主存块映射到Cache固定组的任意行（组间模映射、组内全映射）</td><td>综合直接映射和全相联映射优点，兼顾灵活性与实现成本</td><td>实现较复杂，需一定数量比较器</td></tr></tbody></table><h2 id="三、Cache地址划分与组织结构"><a href="#三、Cache地址划分与组织结构" class="headerlink" title="三、Cache地址划分与组织结构"></a>三、Cache地址划分与组织结构</h2><ul><li><strong>地址划分</strong>：<ul><li><strong>标记（Tag）</strong>：用于标识主存块。</li><li><strong>索引（Index）</strong>：用于定位Cache行或组。</li><li><strong>字节偏移（Byte Offset）</strong>：用于定位块内具体字节。</li></ul></li><li><strong>有效位（Valid Bit）</strong>：<ul><li>标记Cache行数据是否有效（1有效，0无效或初始状态）。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cache块有效性</title>
      <link href="/2025/09/03/Cache%E5%9D%97%E6%9C%89%E6%95%88%E6%80%A7/"/>
      <url>/2025/09/03/Cache%E5%9D%97%E6%9C%89%E6%95%88%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="Cache块有效性"><a href="#Cache块有效性" class="headerlink" title="Cache块有效性"></a>Cache块有效性</h2><h3 id="一，什么是Cache的有效性"><a href="#一，什么是Cache的有效性" class="headerlink" title="一，什么是Cache的有效性"></a>一，什么是Cache的有效性</h3><p>在 Cache 结构中，数据是以块（Block 或 Line）为单位存储的。每个 Cache 块通常包含以下几个部分</p><ul><li>数据块：主存中的数据副本</li><li>标记（Tag）：用于标识对于主存地址</li><li>有效位：表示Cache块是否有效</li></ul><h3 id="二，为什么需要-Cache-块有效性"><a href="#二，为什么需要-Cache-块有效性" class="headerlink" title="二，为什么需要 Cache 块有效性"></a>二，为什么需要 Cache 块有效性</h3><p>当计算机刚启动时，Cache 为空，其中的数据是不确定的。此时，如果没有有效位，CPU 可能会误用这些无效数据，导致程序错误。因此，<strong>有效位的作用就是防止访问无效数据</strong>。</p><table><thead><tr><th>有效位</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>Cache行无效，数据不可用，必须从内存重新加载</td></tr><tr><td>1</td><td>Cache行有效，数据可用，可以直接读取</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法(C++实现)</title>
      <link href="/2025/09/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(C++%E5%AE%9E%E7%8E%B0)/"/>
      <url>/2025/09/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(C++%E5%AE%9E%E7%8E%B0)/</url>
      
        <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">selection_sort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> min_index = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[min_index])&#123;</span><br><span class="line">                min_index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr[i],arr[min_index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shell_sort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> gap=n/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=gap;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> temp = arr[i];</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=i;j&gt;=gap &amp;&amp; arr[j-gap]&gt;temp;j-=gap)&#123;</span><br><span class="line">                arr[j] = arr[j-gap];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertion_sort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> key = arr[i];</span><br><span class="line">        <span class="type">int</span> j = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; arr[j]&gt;key)&#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="type">int</span> pivot = arr[high];</span><br><span class="line">        <span class="type">int</span> i = low - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=low;j&lt;high;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; pivot)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                swap(arr[i],arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr[i+<span class="number">1</span>],arr[high]);</span><br><span class="line">        quick_sort(arr, low, i);</span><br><span class="line">        quick_sort(arr, i+<span class="number">2</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = new <span class="type">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> i = left, j = mid+<span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; arr[j])&#123;</span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) temp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= right) temp[k++] = arr[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=left, k=<span class="number">0</span>;i&lt;=right;i++,k++)&#123;</span><br><span class="line">        arr[i] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">    delete[] temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        merge_sort(arr, left, mid);</span><br><span class="line">        merge_sort(arr, mid+<span class="number">1</span>, right);</span><br><span class="line">        merge(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">100000</span>;</span><br><span class="line">    <span class="type">int</span>* arr = generate_data(n);</span><br><span class="line">    <span class="comment">// 评判每个算法的排序时间</span></span><br><span class="line">    <span class="type">clock_t</span> start, end;</span><br><span class="line"></span><br><span class="line">    start = clock();</span><br><span class="line">    bubble_sort(arr, n);</span><br><span class="line">    end = clock();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bubble Sort Time: &quot;</span> &lt;&lt; (<span class="type">double</span>)(end - start) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    start = clock();</span><br><span class="line">    selection_sort(arr, n);</span><br><span class="line">    end = clock();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Selection Sort Time: &quot;</span> &lt;&lt; (<span class="type">double</span>)(end - start) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    start = clock();</span><br><span class="line">    shell_sort(arr, n);</span><br><span class="line">    end = clock();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Shell Sort Time: &quot;</span> &lt;&lt; (<span class="type">double</span>)(end - start) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    start = clock();</span><br><span class="line">    insertion_sort(arr, n);</span><br><span class="line">    end = clock();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Insertion Sort Time: &quot;</span> &lt;&lt; (<span class="type">double</span>)(end - start) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    start = clock();</span><br><span class="line">    quick_sort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    end = clock();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Quick Sort Time: &quot;</span> &lt;&lt; (<span class="type">double</span>)(end - start) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    start = clock();</span><br><span class="line">    merge_sort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    end = clock();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Merge Sort Time: &quot;</span> &lt;&lt; (<span class="type">double</span>)(end - start) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    delete[] arr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/image_1756822813078.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 常用命令</title>
      <link href="/2025/08/11/JVM-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2025/08/11/JVM-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>JPS</strong>：JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</li><li><strong>jstat</strong>：jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</li><li><strong>jmap</strong>：jmap(JVM Memory Map)命令用于生成heap dump文件，如果不使用这个命令，还阔以使用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候自动生成dump文件。 jmap不仅能生成dump文件，还阔以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。</li><li><strong>jhat</strong>： jhat(JVM Heap Analysis Tool)命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP&#x2F;HTML服务器，生成dump的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析。</li><li><strong>jstack</strong>：jstack用于生成java虚拟机当前时刻的线程快照。jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sleep() 和 wait() 有什么区别</title>
      <link href="/2025/08/11/sleep-%E5%92%8C-wait-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/08/11/sleep-%E5%92%8C-wait-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p><strong>sleep方法</strong>：是Thread类的静态方法，当前线程将睡眠n毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进入可运行状态，等待CPU的到来。睡眠不释放锁（如果有的话）</p><p><strong>wait方法</strong>：是Object的方法，必须与synchronized关键字一起使用，线程进入阻塞状态，当notify或者notifyall被调用后，会解除阻塞。但是，只有重新占用互斥锁之后才会进入可运行状态。睡眠时，会释放互斥锁；</p><p><strong>在 Java 中，</strong><code>sleep()</code> 和 <code>wait()</code> 都是用于线程控制的方法，但它们有以下几个关键区别：</p><ol><li><strong>所属类不同</strong></li></ol><ul><li><code>sleep()</code> 是 <code>Thread</code> 类的静态方法</li><li><code>wait()</code> 是 <code>Object</code> 类的实例方法</li></ul><ol start="2"><li><strong>对锁的影响不同</strong></li></ol><ul><li><code>sleep()</code> 不会释放当前线程所持有的锁</li><li><code>wait()</code> 会释放当前线程所持有的锁，让其他线程有机会获取该锁</li></ul><ol start="3"><li><strong>唤醒方式不同</strong></li></ol><ul><li><code>sleep()</code> 时间到后会自动唤醒，或者被 <code>interrupt()</code> 方法中断唤醒</li><li><code>wait()</code> 需要其他线程调用相同对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法才能唤醒，或者指定等待时间后自动唤醒</li></ul><ol start="4"><li><strong>使用场景不同</strong></li></ol><ul><li><code>sleep()</code> 通常用于暂停线程执行一段固定时间，不依赖于其他线程的状态</li><li><code>wait()</code> 通常用于线程间通信，让线程等待某个条件满足后再继续执行</li></ul><ol start="5"><li><strong>调用要求不同</strong></li></ol><ul><li><code>sleep()</code> 可以在任何地方调用，不需要持有对象锁</li><li><code>wait()</code> 必须在同步代码块（<code>synchronized</code>）中调用，且当前线程必须持有该对象的锁</li></ul><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sleep() 示例</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>); <span class="comment">// 让当前线程休眠1秒，不释放锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// wait() 示例</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">    obj.wait(); <span class="comment">// 释放obj对象的锁，进入等待状态</span></span><br><span class="line">    <span class="comment">// 或指定等待时间</span></span><br><span class="line">    obj.wait(<span class="number">1000</span>); <span class="comment">// 最多等待1秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，当 <code>wait()</code> 被唤醒后，线程不会立即执行，而是需要重新获取对象锁后才能继续执行。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库三范式的理解与看法</title>
      <link href="/2025/08/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E7%9C%8B%E6%B3%95/"/>
      <url>/2025/08/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E7%9C%8B%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>数据库三范式（First Normal Form, 1NF；Second Normal Form, 2NF；Third Normal Form, 3NF）是关系型数据库设计中用于减少数据冗余、避免更新异常（插入、删除、修改异常）的核心原则。其本质是通过对数据表的结构化拆分，确保数据的“原子性”和“依赖合理性”，最终实现数据的一致性和可维护性。</p><h3 id="1-三范式的核心定义与作用"><a href="#1-三范式的核心定义与作用" class="headerlink" title="1. 三范式的核心定义与作用"></a>1. 三范式的核心定义与作用</h3><ul><li><strong>第一范式（1NF）：要求数据表中的每个属性（列）都是“原子性”的，即不可再分。</strong><br>例如，“地址”字段若包含“省、市、区”，需拆分为独立列，否则无法单独查询“某省的用户”，会导致查询效率低且数据混乱。<br>作用：确保数据的最小粒度，为后续的依赖关系规范奠定基础。</li><li><strong>第二范式（2NF）</strong>：在 1NF 的基础上，要求非主属性（非主键列）完全依赖于主键（而非主键的一部分，即“消除部分依赖”）。<br>例如，“学生选课表”中，若主键是（学生 ID，课程 ID），则“学生姓名”仅依赖“学生 ID”（部分依赖），需拆分为“学生表”（存学生 ID、姓名）和“选课表”（存学生 ID、课程 ID、成绩）。<br>作用：避免因主键部分字段变化导致的非主属性冗余（如同一学生选多门课，姓名会重复存储）。</li><li><strong>第三范式（3NF）</strong>：在 2NF 的基础上，要求非主属性之间不存在“传递依赖”（即非主属性不能依赖于其他非主属性）。<br>例如，“学生表”中若有“学生 ID、学院 ID、学院名称”，则“学院名称”依赖于“学院 ID”（传递依赖于主键“学生 ID”），需拆分为“学生表”（学生 ID、学院 ID）和“学院表”（学院 ID、学院名称）。<br>作用：避免因非主属性变化导致的连锁更新（如学院名称修改时，无需更新所有学生的记录）。</li></ul><h3 id="2-三范式的价值与局限性"><a href="#2-三范式的价值与局限性" class="headerlink" title="2. 三范式的价值与局限性"></a>2. 三范式的价值与局限性</h3><ul><li><strong>价值</strong>：<br>三范式是数据库设计的“基准线”，其核心价值在于通过结构化拆分减少冗余，降低数据不一致的风险。对于业务稳定、数据量中等、以“事务性操作”（如订单、用户管理）为主的系统，严格遵循三范式可显著提升数据维护效率（如修改一条学院名称，仅需改学院表，无需动学生表）。</li><li><strong>局限性</strong>:<br>过度规范化可能导致“拆分过度”：表数量激增，查询时需频繁进行多表连接（JOIN），反而降低查询性能（尤其数据量极大时）。例如，电商订单查询需关联“订单表、用户表、商品表、地址表、支付表”等，多表连接会增加数据库 IO 压力。<br>此外，部分场景需“反范式设计”（主动保留冗余）：如数据仓库的报表场景，为提升查询速度，会将多表数据合并为宽表（冗余存储），牺牲部分维护性换取性能。</li></ul><h3 id="3-实际应用中的平衡"><a href="#3-实际应用中的平衡" class="headerlink" title="3. 实际应用中的平衡"></a>3. 实际应用中的平衡</h3><p>三范式并非“绝对准则”，而是需要结合业务场景灵活调整：</p><ul><li>事务型系统（如银行转账）：需严格遵循三范式，优先保证数据一致性；</li><li>分析型系统（如电商数据分析）：可适当反范式，优先保证查询效率；</li><li>折中方案：通过“冗余字段 + 触发器&#x2F;定时任务”维护一致性（如订单表冗余“商品名称”，同时用触发器同步商品表的名称更新）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new String(&quot;abc&quot;)创建了多少个对象？</title>
      <link href="/2025/08/08/new-String-abc-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F/"/>
      <url>/2025/08/08/new-String-abc-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>在 Java 中，使用 <strong><code>new String(&quot;abc&quot;)</code> 可能创建 <strong>1 个或 2 个对象</strong></strong>，具体取决于字符串常量池（String Pool）中是否已存在 “abc” 这个字符串：</p><ol><li><strong>如果常量池中不存在 “abc”：</strong></li></ol><ul><li><strong>会先在常量池中创建一个 “abc” 对象。</strong></li><li>再通过 <code>new</code> 关键字在堆内存中创建一个新的 String 对象（该对象的值与常量池中的 “abc” 相同）。</li><li><strong>总共创建 <strong><strong>2 个对象</strong></strong>。</strong></li></ul><ol start="2"><li><strong>如果常量池中已存在 “abc”</strong>：</li></ol><ul><li>仅通过 <code>new</code> 关键字在堆内存中创建一个新的 String 对象（该对象的值引用常量池中的 “abc”）。</li><li>总共创建 <strong><strong>1 个对象</strong></strong>。</li></ul><p>这是因为 <code>new String(&quot;abc&quot;)</code>会强制在堆中生成一个新对象，而直接使用字符串字面量（如<code>&quot;abc&quot;</code>）则会优先复用常量池中的已有对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL面试题</title>
      <link href="/2025/08/08/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/08/08/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="MyISAM和InnoDB的区别有哪些"><a href="#MyISAM和InnoDB的区别有哪些" class="headerlink" title="MyISAM和InnoDB的区别有哪些"></a>MyISAM和InnoDB的区别有哪些</h3><ul><li>InnoDB支持事务, MyISAM不支持</li><li>InnoDB支持行级锁, MyISAM支持表级锁</li><li>InnoDB支持多版本并发控制(MVVC), MyISAM不支持</li><li>InnoDB支持外键, MyISAM不支持</li><li>MyISAM支持全文索引, InnoDB部分版本不支持(但可以使用Sphinx插件)</li></ul><h3 id="MySQL怎么恢复半个月前的数据"><a href="#MySQL怎么恢复半个月前的数据" class="headerlink" title="MySQL怎么恢复半个月前的数据"></a>MySQL怎么恢复半个月前的数据</h3><p>通过整库备份+binlog进行恢复. 前提是要有定期整库备份且保存了binlog日志</p><h3 id="MySQL事务的隔离级别-分别有什么特点"><a href="#MySQL事务的隔离级别-分别有什么特点" class="headerlink" title="MySQL事务的隔离级别, 分别有什么特点"></a>MySQL事务的隔离级别, 分别有什么特点</h3><ul><li>读未提交(RU): 一个事务还没提交时, 它做的变更就能被别的事务看到</li><li>读提交(RC): 一个事务提交之后, 它做的变更才会被其他事务看到</li><li>可重复读(RR): 一个事务执行过程中看到的数据, 总是跟这个事务在启动时看到的数据是一致的. 当</li></ul><p>然在可重复读隔离级别下, 未提交变更对其他事务也是不可见的</p><ul><li>串行化(S): 对于同一行记录, 读写都会加锁. 当出现读写锁冲突的时候, 后访问的事务必须等前一个</li></ul><p>事务执行完成才能继续执行</p><h3 id="MySQL中有哪几种锁"><a href="#MySQL中有哪几种锁" class="headerlink" title="MySQL中有哪几种锁"></a>MySQL中有哪几种锁</h3><ul><li>表级锁： 开销小， 加锁快； 不会出现死锁； 锁定粒度大， 发生锁冲突的概率最高， 并发度最低。</li><li>行级锁： 开销大， 加锁慢； 会出现死锁； 锁定粒度最小， 发生锁冲突的概率最低， 并发度也最</li></ul><p><strong>高。</strong></p><ul><li>页面锁： 开销和加锁时间界于表锁和行锁之间； 会出现死锁； 锁定粒度界于表锁和行锁之间， 并</li></ul><p><strong>发度一般。</strong></p><h3 id="MySQL-中有哪些不同的表格"><a href="#MySQL-中有哪些不同的表格" class="headerlink" title="MySQL 中有哪些不同的表格"></a>MySQL 中有哪些不同的表格</h3><p>共有 5 种类型的表格： 1、MyISAM2、Heap 3、Merge 4、INNODB 5、MISAM</p><h3 id="MySQL-中InnoDB-支持的四种事务隔离级别名称，以及逐级之间的区别？"><a href="#MySQL-中InnoDB-支持的四种事务隔离级别名称，以及逐级之间的区别？" class="headerlink" title="MySQL 中InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？"></a>MySQL 中InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？</h3><ul><li>read uncommited ： 读到未提交数据</li><li>read committed： 脏读， 不可重复读</li><li>repeatable read： 可重读</li><li>serializable ： 串行事物</li></ul><h3 id="CHAR-和VARCHAR-的区别"><a href="#CHAR-和VARCHAR-的区别" class="headerlink" title="CHAR 和VARCHAR 的区别"></a>CHAR 和VARCHAR 的区别</h3><ul><li><strong>char</strong>：定长，存取效率高，一般用于固定长度的表单提交数据存储，例如：身份证号，手机号，电话，密码等，长度不够的时候，会采取右补空格的方式。</li><li><strong>varchar</strong>：不定长，更节省空间，需要用一个或者两个字节来存储数据的长度。具体规则是：如果列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节。</li></ul><h3 id="SQL语句主要分为哪几类"><a href="#SQL语句主要分为哪几类" class="headerlink" title="SQL语句主要分为哪几类"></a>SQL语句主要分为哪几类</h3><ul><li><strong>数据定义语言DDL</strong>（Data Ddefinition Language）CREATE，DROP，ALTER，主要为以上操作即对逻辑结构等有操作的，其中包括表结构，视图和索引。</li><li><strong>数据查询语言DQL</strong>（Data Query Language）SELECT，这个较为好理解，即查询操作，以select关键字，各种简单查询，连接查询等，都属于DQL。</li><li><strong>数据操纵语言DML</strong>（Data Manipulation Language）INSERT，UPDATE，DELETE 主要为以上操作，即对数据进行操作的，DQL与DML共同构建了常用的增删改查操作。</li><li><strong>数据控制功能DCL</strong>（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK主要为以上操作即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。</li></ul><h3 id="SQL-约束有哪些"><a href="#SQL-约束有哪些" class="headerlink" title="SQL 约束有哪些"></a>SQL 约束有哪些</h3><ul><li><strong>NOT NULL</strong>: 用于控制字段的内容一定不能为空（NULL）。</li><li><strong>UNIQUE</strong>: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li><li><strong>PRIMARY KEY</strong>: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li><li><strong>FOREIGN KEY</strong>: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li></ul><h3 id="主键和外键"><a href="#主键和外键" class="headerlink" title="主键和外键"></a>主键和外键</h3><ul><li><strong>主键</strong>：表中经常有一个列或多列的组合，其值能唯一地标识表中的每一行，这样的一列或多列称为表的主键，通过它可强制表的实体完整性。一个表只能有一个 PRIMARY KEY 约束，而且 PRIMARY KEY 约束中的列不能接受空值。</li><li><strong>外键</strong>：在一个表中存在的另一个表的主键称此表的外键。</li></ul><h3 id="in和exists的区别"><a href="#in和exists的区别" class="headerlink" title="in和exists的区别"></a>in和exists的区别</h3><p><strong>在 MySQL 中，IN 关键字用于在一个字段中匹配多个值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select column from table where column in (n1, n2, ...)</span><br></pre></td></tr></table></figure><p><strong>EXISTS 关键字用于检查子查询的结果是否为空</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select column1, column2 from table_1 where exists (select * from table2 where xxx=xxx)</span><br></pre></td></tr></table></figure><p><strong>如果查询的两个表大小相当，那么用in和exists差别不大。如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</strong></p><h3 id="drop-delete-truncate的区别"><a href="#drop-delete-truncate的区别" class="headerlink" title="drop delete truncate的区别"></a>drop delete truncate的区别</h3><table><thead><tr><th></th><th><strong>Delete</strong></th><th><strong>Truncate</strong></th><th><strong>Drop</strong></th></tr></thead><tbody><tr><td><strong>类型</strong></td><td><strong>属于DML</strong></td><td><strong>属于DDL</strong></td><td><strong>属于DDL</strong></td></tr><tr><td><strong>回滚</strong></td><td><strong>可回滚</strong></td><td><strong>不可回滚</strong></td><td><strong>不可回滚</strong></td></tr><tr><td><strong>删除内容</strong></td><td><strong>表结构还在，删除表的全部或者一部分数据行</strong></td><td><strong>表结构还在，删除表中的所有数据</strong></td><td><strong>从数据库中删除表，所有的数据行，索引和权限也会被删除</strong></td></tr><tr><td><strong>删除速度</strong></td><td><strong>删除速度慢，需要逐行删除</strong></td><td><strong>删除速度快</strong></td><td><strong>删除速度最快</strong></td></tr></tbody></table><h3 id="replace-into-和-insert-on-duplicate-key-update的区别"><a href="#replace-into-和-insert-on-duplicate-key-update的区别" class="headerlink" title="replace into 和 insert on duplicate key update的区别"></a>replace into 和 insert on duplicate key update的区别</h3><ul><li><code>replace into</code>和<code>on duplcate key update</code>都是只有在<code>primary key</code>或者<code>unique key</code>冲突的时候才会执行“更新操作”。</li><li><code>replace into</code> 会将已有的数据删除然后重新插入，这样就会有一种情况，如果某些字段有默认值，但是<code>replace into</code>语句的字段不完整，则会设置成默认值，主键id会变更。</li><li><code>on duplicate key update</code>则是执行<code>update</code>后面的语句</li></ul><h3 id="UNION-ALL与UNION的区别"><a href="#UNION-ALL与UNION的区别" class="headerlink" title="UNION ALL与UNION的区别"></a>UNION ALL与UNION的区别</h3><ul><li><strong>返回结果</strong></li></ul><p><strong>union all是直接连接，取到得是所有值，记录可能有重复；</strong></p><p><strong>union 是取唯一值，记录没有重复。</strong></p><ul><li><strong>排序</strong></li></ul><p><strong>union将会按照字段的顺序进行全量排序；</strong></p><p><strong>union all只是简单的将两个结果合并后就返回。</strong></p><ul><li><strong>效率</strong></li></ul><p>从效率上说，union all 要比union快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用union all。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
